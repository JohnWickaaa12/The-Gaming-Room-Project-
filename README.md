# The-Gaming-Room-Project-
CS-230 Final Project

Project: The Gaming Room – Draw It or Lose It

Client and Software Requirements

The client, The Gaming Room, wanted to expand their Android-only game, Draw It or Lose It, into a cross-platform, web-based application. The new system needed to support multiple devices and operating systems, allow multiple teams and players, enforce unique names, and ensure only one active game manager instance at a time. The software requirements emphasized scalability, security, and efficient memory management while following object-oriented programming principles in Java.

What I Did Well

I did particularly well at structuring the design document clearly and aligning business requirements with technical requirements. My explanation of the three-layer system architecture (presentation, application, and data layers) and my choice of design patterns (Singleton and Iterator) showed a strong understanding of OOP concepts and how to apply them to real-world software design.

Helpful Aspects of the Process

Working through the design document before coding helped me think ahead about scalability, memory management, and platform differences. By comparing operating systems (Linux, Windows, Mac, and mobile), I gained perspective on deployment tradeoffs and security concerns that I may not have considered if I jumped straight into implementation.

What I Would Revise

If I could revise one part of my document, I would improve the detail and clarity of the UML diagrams to capture more relationships and edge cases. This would make the document even more valuable for future developers who work on extending the system.

Interpreting User Needs

The user’s needs were built directly into the design—such as enforcing unique names, ensuring fairness in team play, and supporting cross-device access. Considering the user’s perspective is vital because software success depends on whether it actually solves their problems and delivers a smooth experience. By keeping users’ needs central, I ensured the design would be both functional and user-friendly.

Approach to Software Design

My approach was to start with requirements gathering, then address design constraints and platform tradeoffs, and finally create a domain model that maps the game’s structure. I used design patterns (Singleton and Iterator) to keep the system efficient and maintainable. In future projects, I would use iterative prototyping and more detailed modeling (like sequence diagrams) earlier in the process to validate design choices before development begins.

